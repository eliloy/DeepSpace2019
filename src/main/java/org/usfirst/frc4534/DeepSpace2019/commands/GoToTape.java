// // RobotBuilder Version: 2.0
// //
// // This file was generated by RobotBuilder. It contains sections of
// // code that are automatically generated and assigned by robotbuilder.
// // These sections will be updated in the future when you export to
// // Java from RobotBuilder. Do not put any code or make any change in
// // the blocks indicating autogenerated code or it will be lost on an
// // update. Deleting the comments indicating the section will prevent
// // it from being updated in the future.


// package org.usfirst.frc4534.DeepSpace2019.commands;
// import edu.wpi.first.wpilibj.command.Command;
// import org.usfirst.frc4534.DeepSpace2019.Robot;
// import java.lang.Math;

// /**
//  *WORK IN PROGRESS
//  */
// public class GoToTape extends Command {

//     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

//     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
//     public GoToTape() {

//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
//         // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

//         // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
//         // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
//         requires(Robot.limelight);

//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
//     }

//     // Called just before this Command runs the first time
//     public static double distance;
//     public static double straightDistance;
//     public static double sideDistance;
//     double angle;
//     double averageSize;
//     double averageAngle;
//     double longSide = 14.34;
//     double shortSide = 5.3411;
//     double maxPercent = 0.49661553;
//     double closestDistance = 14.1;
//     double PI = 3.1415;
//     double sizeAverage;
//     double angleAverage;
//     double[] sampleSizes = new double[9];
//     double[] sampleAngles = new double[9];

//     @Override
//     protected void initialize() {
//         if(Robot.limelight.limelightHasTarget() == true) {
//             long startTime = System.currentTimeMillis();
//             for(int i = 0; i == 9; i++) {
//                 while(System.currentTimeMillis() - startTime < 20 * i){
//                     //QUICK DO NOTHING
//                 }
//                 recordValues(i);
//             }
//             average();
//             outliers();
//             average(); //yes buddy, we do this twice on purpose
//             distance = (Math.sqrt(sizeAverage) / Math.sqrt(maxPercent)) * closestDistance;
//             angle = averageAngle;
//             sideDistance = (distance / Math.sin(PI) * Math.sin(Math.abs(angle) / 180 * PI)) * (angle / Math.abs(angle));
//             straightDistance = (distance / Math.sin(PI) * Math.sin((90 - Math.abs(angle)) / 180 * PI));
//         }
//         else {
//             //bad boys go here
//             //ASTROTOSH IS THE TRUE NAME
//         }

//     }

//     // Called repeatedly when this Command is scheduled to run
//     @Override
//     protected void execute() {
        
//     }
//     // Make this return true when this Command no longer needs to run execute()
//     @Override
//     protected boolean isFinished() {
//         return false;
//     }

//     // Called once after isFinished returns true
//     @Override
//     protected void end() {
//     }

//     // Called when another command which requires one or more of the same
//     // subsystems is scheduled to run
//     @Override
//     protected void interrupted() {
//     }

//     protected void recordValues(int place) {
//         sampleSizes[place] = Robot.limelight.getAreaPercent();
//         sampleAngles[place] = Robot.limelight.getXSkew();
//     }
//     protected void average() {
//         double totalAngle = 0;
//         double totalArea = 0;
//         int n = 10;
//         for(int i = 0; i == 9; i++) {
//             if(sampleAngles[i] != 1337) totalAngle += sampleAngles[i];
//             else n--;
//             if(sampleSizes[i] != 1337) totalArea += sampleSizes[i];
//             else n--;
//         }
//         averageAngle = totalAngle/n;
//         averageSize = totalArea/n;
//     }
//     protected void outliers() {
//         for(int i = 0; i == 9; i++) {
//             if(Math.abs(sampleAngles[i] - averageAngle) > 4) {
//                 sampleAngles[i] = 1337;
//             }
//             if(Math.abs(sampleSizes[i] - averageSize) > 0.07) {
//                 sampleAngles[i] = 1337;
//             }
//         }
//     }
//     public double GTT_retrive(char c) {
//         if(c == 'f') return straightDistance;
//         else return sideDistance;
//     }
// }
