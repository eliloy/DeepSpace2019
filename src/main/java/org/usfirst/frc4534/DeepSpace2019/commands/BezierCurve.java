// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
// Haha enjoy doing a git merge loser ヽ( •_)ᕗ

package org.usfirst.frc4534.DeepSpace2019.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc4534.DeepSpace2019.Robot;
import java.lang.Math;
/**
 *
 */
public class BezierCurve extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    double[] xList = new double[10];
    double[] yList = new double[10];
    int t;
    double m_P0x;
    double m_P0y;
    double m_P1x;
    double m_P1y;
    double m_P2x;
    double m_P2y;
    double m_P3x;
    double m_P3y;
    double angle;
    double distance;
    double PI = 3.14159;
    int speed = 10;
    int m_precision;
    boolean m_relative;
    double m_ratio = 0.5;
    int cycles = 0;
    double pringle = 0;
    double b;
    double r;
    double fangle;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public BezierCurve(double P0x, double P0y, double P1x, double P1y, double P2x, double P2y, double P3x, double P3y, int precision, boolean relative, double ratio) {
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    	m_P0x = P0y;
    	m_P0y = P0x;
    	m_P1x = P1y;
    	m_P1y = P1x;
    	m_P2x = P2y;
	    m_P2y = P2x;
    	m_P3x = P3y;
	    m_P3y = P3x;
    	m_precision = precision;
	    t = 0;
    	angle = 0;
	    distance = 0;
     	m_relative = relative;
        pringle = Math.atan2(P1y - P0y, P1x - P0x);
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        t = 1;
        angle = 0;
        distance = 0;
        xList[6] = m_P0x;
        xList[6] = m_P0y;
        Robot.driveTrain.resetDistanceCounter();
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        if(Robot.driveTrain.getLeftDistanceCounter() + Robot.driveTrain.getRightDistanceCounter() / 2 >= r * angle || t == 1) {
            Robot.driveTrain.resetDistanceCounter();
            //Calculates time / precision of the lines. See https://upload.wikimedia.org/wikipedia/commons/d/db/B%C3%A9zier_3_big.gif
            xList[0] = m_P0x + ((m_P1x - m_P0x) * ((double)t / m_precision)); //Grey line P0=P1 point x
            yList[0] = m_P0y + ((m_P1y - m_P0y) * ((double)t / m_precision)); //Grey line P0=P1 point y
            xList[1] = m_P1x + ((m_P2x - m_P1x) * ((double)t / m_precision)); //Grey line P1=P2 point x
            yList[1] = m_P1y + ((m_P2y - m_P1y) * ((double)t / m_precision)); //Grey line P1=P2 point y
            xList[2] = m_P2x + ((m_P3x - m_P2x) * ((double)t / m_precision)); //Grey line P2=P3 point x
            yList[2] = m_P2y + ((m_P3y - m_P2y) * ((double)t / m_precision)); //Grey line P2=P3 point y
            xList[3] = xList[0] + ((xList[1] - xList[0]) * ((double)t / m_precision)); //Green line point 1 x
            yList[3] = yList[0] + ((yList[1] - yList[0]) * ((double)t / m_precision)); //Green line point 1 y
            xList[4] = xList[1] + ((xList[2] - xList[1]) * ((double)t / m_precision)); //Green line point 2 x
            yList[4] = yList[1] + ((yList[2] - yList[1]) * ((double)t / m_precision)); //Green line point 2 y
            xList[5] = xList[3] + ((xList[4] - xList[3]) * ((double)t / m_precision)); //Blue line point x
            yList[5] = yList[3] + ((yList[4] - yList[3]) * ((double)t / m_precision)); //Blue line point y
            //Increments time
            t++;
            //Uses gyro to caculate angle difference (present angle to needed one)
            if(m_relative == false)
            {
                if(Robot.driveTrain.getGyroAngle() < 0)
                {
                    angle = Math.atan2(yList[5] - yList[6], xList[5] - xList[6]) - ((Robot.driveTrain.getGyroAngle()% -360) / 360 * (2 * PI));
                }
                else
                {
                    angle = Math.atan2(yList[5] - yList[6], xList[5] - xList[6]) - ((Robot.driveTrain.getGyroAngle() % 360) / 360 * (2 * PI));
                }
            }
            //Uses current calculated angle to caculate angle difference (present angle to needed one), will assume first grey line represents robots current angle.
            else
            {
                fangle = Math.atan2(yList[5] - yList[6], xList[5] - xList[6]);
                angle = fangle - pringle;
                pringle = fangle;
            }
            //Makes sure the angle isn't over 90 (degrees), indicating a "cusp" error. If it is, lowers angle until it is below 90.
            //For cusp see https://proxy.duckduckgo.com/iu/?u=http%3A%2F%2Fwww.sosmath.com%2Fcalculus%2Fdiff%2Fder09%2FImage02.gif&f=1
            //note how you could rotate the two "wings" to remove the cusp and make a seamless curve like:
            //https://proxy.duckduckgo.com/iur/?f=1&image_host=http%3A%2F%2Fwww.vitutor.com%2Fgeometry%2Fconics%2Fimages%2F106.gif&u=https://www.vitutor.com/geometry/conics/images/106.gif
            if(angle > PI / 2) {
                while(angle > PI / 2) {
                    angle = angle - PI;
                }
            }
            //Makes sure the angle isnt under -90 (degrees), indicating a "cusp" error. If it is, lowers angle until it is above -90.
            if(angle < PI / -2) {
                while(angle < PI / -2) {
                    angle = angle + PI;
                }
            }
            //Calculates distance needed to travel, based on current pos(list[6]) and target (List[5])
            distance = Math.sqrt(Math.pow(xList[6] - xList[5], 2) + Math.pow(yList[6] - yList[5], 2));
            //Shifts the "current" target point to the previous one slot.
            xList[6] = xList[5];
            yList[6] = yList[5];
            //Testing values in dashboard for troubleshooting
            }
            if(!(distance == 0)) {
                //Calculates an arc on a circle that will go the distance while turning the angle
                b = (PI - angle) / 2;
                r = Math.sin(b) / (Math.sin(angle) / distance);
                //Testing values in dashboard for troubleshooting
                //Starts traveiling along the arc at speed (ratio). Goes until the distance is met.
                if(angle 
                > 0) Robot.driveTrain.TankDrive(m_ratio, ((r - 11.75) / (r + 11.75)) * m_ratio);
                if(angle < 0) Robot.driveTrain.TankDrive((r + 11.75) / (r - 11.75) * m_ratio, m_ratio);
                if(angle == 0) Robot.driveTrain.TankDrive(m_ratio, m_ratio);
        }
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        if(t == m_precision + 1) return true;
        else return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.driveTrain.TankDrive(0, 0);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        Robot.driveTrain.TankDrive(0, 0);
    }
}

